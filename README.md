ЛР6

Роботу виконали студенти групи ІО-02:
- Воловик Олександр
- Литвиненко Данило
- Шумельчук Юрій

Варіант 16:
><b>Тема:</b> Оренда квартир
<br><b>Сутності:</b> Квартира, параметри квартири, опис
<br><b>Актори:</b> Хазяїн квартири, клієнт 
<br><b>Сценарії використання:</b> 
<br>Хазяїн квартири: Створення/редагування/видалення інформації про квартиру
<br>Клієнт: пошук квартири по параметрам

Тестування розробленого API на відповідність опису у документації за допомогою Postman:

GET /api/orders

![Screenshot](readme/GET_orders_doc.png)
![Screenshot](readme/GET_orders_200.png)

GET /api/rooms (Фільтрація по параметрах та пагінація)

![Screenshot](readme/GET_rooms_doc.png)
![Screenshot](readme/GET_rooms_200.png)
![Screenshot](readme/GET_rooms_200_filtered.png)
![Screenshot](readme/GET_rooms_200_filtered2.png)
![Screenshot](readme/GET_rooms_200_paginated.png)

POST /api/rooms

![Screenshot](readme/POST_rooms_doc.png)
![Screenshot](readme/POST_rooms_200.png)
![Screenshot](readme/POST_rooms_400.png)
![Screenshot](readme/POST_rooms_401.png)

GET /api/rooms/{id}

![Screenshot](readme/GET_rooms_id_doc.png)
![Screenshot](readme/GET_rooms_id_200.png)
![Screenshot](readme/GET_rooms_id_404.png)

PUT /api/rooms/{id}

![Screenshot](readme/PUT_rooms_id_doc.png)
![Screenshot](readme/PUT_rooms_id_200.png)
![Screenshot](readme/PUT_rooms_id_400.png)
![Screenshot](readme/PUT_rooms_id_401.png)
![Screenshot](readme/PUT_rooms_id_404.png)

DELETE /api/rooms/{id}

![Screenshot](readme/DELETE_rooms_id_doc.png)
![Screenshot](readme/DELETE_rooms_id_200.png)
![Screenshot](readme/DELETE_rooms_id_401.png)
![Screenshot](readme/DELETE_rooms_id_404.png)

Контрольні питання:

1. Що таке ORM?
 > <b>ORM</b> (Object-Relational Mapping) – технологія програмування, яка пов'язує бази даних із концепціями об'єктно-орієнтованих мов програмування, створюючи «віртуальну об'єктну базу даних». Існують як пропрієтарні, і вільні реалізації цієї технології. <br> Загалом технологія ORM дозволяє проектувати роботу з даними в термінах класів, а не таблиць даних. Вона дозволяє перетворювати класи на дані, придатні для зберігання базі даних, причому схему перетворення визначає сам розробник. Крім того, ORM надає простий API-інтерфейс для CRUD-операцій над даними. Завдяки технології ORM немає необхідності писати SQL-код для взаємодії з локальною базою даних.
2. В чому полягає різниця між JPA та Hibernate?
 > <b>JPA</b> – специфікація. <br><br> <b>Hibernate</b> – реалізація. <br><br>JPA також можуть бути свої особливості. JPA це специфікація, а Hibernate – це ORM фреймворк/бібліотека, яка сумісна з JPA. Як і в класичному ООП, клас, який реалізує інтерфейс, може мати додаткові методи/властивості, так і Hiberante має більше можливостей ніж JPA. За деякими даними, сама специфікація JPA була створена на базі ідей, втілених у Hibernate.
3. Поясніть призначення кожного методу з інтерфейсу CrudRepository.
 ><b>Метод save():</b> <br>Зберігає вказану сутність. Використовуйте повернутий екземпляр для подальших операцій, оскільки операція збереження могла повністю змінити екземпляр сутності.<br><br>
> <b>Метод saveAll():</b> <br>Зберігає всі задані сутності.<br><br>
> <b>Метод findById():</b> <br>Отримує сутність за її ідентифікатором.<br><br>
 > <b>Метод existsById():</b>  <br>Повертає, чи існує об’єкт із заданим ідентифікатором.<br></br>
 > <b>Метод findAll():</b> <br>Повертає всі екземпляри типу.<br><br>
 > <b>Метод findAllById():</b> <br>Повертає всі екземпляри типу з указаними ідентифікаторами. Якщо деякі або всі ідентифікатори не знайдено, жодні сутності не повертаються для цих ідентифікаторів. Зауважте, що порядок елементів у результаті не гарантується.<br><br>
 > <b>Метод count():</b> <br>Повертає кількість доступних об’єктів. <br><br>
 > <b>Метод deleteById():</b> <br>Видаляє сутність із заданим ідентифікатором. Якщо сутність не знайдено в сховищі постійності, вона мовчки ігнорується.<br><br> 
 > <b>Метод delete():</b><br> Видаляє вказану сутність. <br><br>
 > <b>Метод deleteAllById():</b><br> Видаляє всі екземпляри типу з указаними ідентифікаторами. Сутності, яких немає в сховищі постійності, мовчки ігноруються.<br><br> 
 > <b>Метод deleteAll():</b><br> Видаляє всі сутності, якими керує репозиторій.<br><br>

4. Яким вимогам має відповідати @Entity-клас?
>1) Entity клас повинен бути позначений анотацією Entity або описаний у файлі XML конфігурації JPA.<br><br> 
>2) Entity клас повинен містити public або protected конструктор без аргументів (він також може мати конструктори з аргументами).<br><br>
>3) Entity клас має бути класом верхнього рівня (top-level class),.<br><br>
>4) Entity клас не може бути enum або інтерфейсом.<br><br>
>5) Entity клас не може бути фінальним класом (final class).<br><br>
>6) Entity клас не може містити фінальні поля або методи, якщо вони беруть участь у мапінгу (persistent final methods or persistent final instance variables).<br><br>
>7) Якщо об'єкт Entity класу передаватиметься за значенням як окремий об'єкт (detached object), наприклад через віддалений інтерфейс (through a remote interface), він також повинен реалізовувати Serializable інтерфейс.<br><br>
>8) Поля Entity клас повинні бути безпосередньо доступні тільки методам самого Entity класу і не повинні бути безпосередньо доступні іншим класам, які використовують цей Entity. Такі класи повинні звертатися тільки до методів (getter/setter методів або інших методів бізнес-логіки в класі Entity), 9) Entity клас повинен містити первинний ключ, тобто атрибут або групу атрибутів, які унікально визначають запис цього Entity класу в базі даних.
5. Які є типи відношень між сутностями у JPA?
> Зв'язки між таблицями бази даних, як правило, більш ефективні. Тому зв’язки між класами сутностей розглядаються як реляційні таблиці (концепція JPA).<br> Існують такі типи відношень: <br>Відношення сутності ManyToOne.<br><br> Відношення сутності OneToMany.<br><br> Відношення OneToOne.<br><br> Відношення сутності ManyToMany.<br><br> 
> Відношення <b>«ManyToOne»</b> між сутностями: де сутність пов’язана одна з одною (стовпцем або групою стовпців), яка містить унікальні значення. Стовпець або набір стовпців. Ці зв'язки застосовуються до реляційних баз даних із використанням зовнішнього ключа між таблицями.<br><br>
> Відношення <b>«OneToMany».</b> У цьому відношенні багато дітей в іншій сутності пов’язані з кожним рядком сутності. Важливо те, що декілька батьків не можуть записувати записи дітей. Кожен рядок у таблиці A пов’язаний з 0,1 або більше рядками таблиці B у зв’язку «один до багатьох» між таблицями A та B.<br><br>
> Відношення <b>«OneToOne».</b> Один елемент може належати лише одному іншому елементу у відношенні сутності «один до одного». Це означає, що кожен рядок сутності стосується лише одного рядка іншої сутності.<br><br>
> Відношення <b>«ManyToMany»</b> — це один або кілька рядків однієї сутності, які з’єднані з кількома рядками в іншій сутності.
6. Для чого потрібні DTO? Чому замість них не завжди можна використовувати @Entity об’єкти?
> <b>Data Transfer Object (DTO)</b> — один із шаблонів проєктування, який використовують для передачі даних між підсистемами програми.<br> 
> Метою DTO є зібрати в одній відповіді стільки інформації, скільки клієнти вважають необхідними для збереження викликів на сервері. Що робить спілкування клієнт-сервер більш плавним.